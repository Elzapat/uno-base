use bevy::prelude::*;
use bevy::render::pass::ClearColor;
use bevy::window::CursorMoved;

pub struct DragAndDropPlugin;

impl Plugin for DragAndDropPlugin {
    fn build(&self, app: &mut AppBuilder) {
        app.add_startup_system(setup.system())
            .add_system(sprite_system.system())
            .run();

    }
}

fn setup(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut materials: ResMut<Assets<ColorMaterial>>,
) {
    // commands.spawn(    // show sprite in the middle of the screen
    // let bevy_texture = asset_server.load("sprites/bevy-icon.png");
    // commands.spawn(SpriteBundle {
    //     sprite: Sprite::new(Vec2::new(SPRITE_SIZE, SPRITE_SIZE)),
    //     material: materials.add(bevy_texture.clone().into()),
    //     ..Default::default()
    // });
}

#[derive(Default)]
struct State {
    // cursor_moved_event_reader: EventReader<CursorMoved>,
    // store current cursor/mouse position
    cursor_pos: Vec2,
    // store entity ID and the difference between sprite center and mouse click location
    sprite: Option<(Entity, Vec3)>,
}

fn sprite_system(
    mut state: Local<State>,
    windows: Res<Windows>,
    mouse_button_input: Res<Input<MouseButton>>,
    mut cursor_moved_events: EventReader<CursorMoved>,
    mut sprites: Query<(Entity, &Sprite)>,
    mut transforms: Query<&mut Transform>,
) {
    let window = windows.get_primary().unwrap();
    let half_window = Vec2::new(window.width() / 2.0, window.height() / 2.0);

    // if cursor has moved, transform to graphics coordinates and store in state.curser_pos
    for cursor_event in cursor_moved_events.iter() {
        println!("test");
        state.cursor_pos = cursor_event.position - half_window;
        state.cursor_pos.x = state.cursor_pos.x;

        // stop dragging if mouse button was released
        if mouse_button_input.just_released(MouseButton::Left) {
            state.sprite = None;
            return;
        }

        // set new sprite position, if mouse button is pressed and a sprite was clicked on
        // take previous click difference into account, to avoid sprite jumps on first move
        if mouse_button_input.pressed(MouseButton::Left) && state.sprite.is_some() {
            let sprite = state.sprite.unwrap();

            let mut sprite_pos = transforms.get_mut(sprite.0).unwrap();

            trace!("Sprite position old: {:?}", sprite_pos.translation);
            sprite_pos.translation.x = state.cursor_pos.x + sprite.1.x;
            sprite_pos.translation.y = state.cursor_pos.y + sprite.1.y;
            trace!("Sprite position new: {:?}", sprite_pos.translation);
            // position clamping was left out intentionally
        }

        // store sprite ID and mouse distance from sprite center, if sprite was clicked
        if mouse_button_input.just_pressed(MouseButton::Left) {
            for (entity, sprite) in sprites.iter_mut() {
                let sprite_pos = transforms.get_mut(entity).unwrap().translation;
                let diff = cursor_to_sprite_diff(&state.cursor_pos, &sprite_pos);
                // sprite is a circle, so check distance from center < sprite radius
                if diff.length() < (sprite.size.x / 2.0) {
                    state.sprite = Some((entity, diff));
                }
            }
        }
    }
}

fn cursor_to_sprite_diff(cursor_pos: &Vec2, sprite_pos: &Vec3) -> Vec3 {
    Vec3::new(
        sprite_pos.x - cursor_pos.x,
        sprite_pos.y - cursor_pos.y,
        0.0,
    )
}
