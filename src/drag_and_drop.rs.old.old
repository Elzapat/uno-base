#![allow(clippy::type_complexity)]

use bevy::{prelude::*, render::camera::Camera};
pub struct DragAndDropPlugin;

impl Plugin for DragAndDropPlugin {
    fn build(&self, app: &mut AppBuilder) {
        app.add_system(cursor_state.system())
            .add_system(cursor_transform.system())
            .add_system(draggable.system())
            .add_system(hoverable.system())
            .add_system(drag.system())
            .add_system(drop.system())
            .add_system(material.system());
    }
}

#[derive(Default)]
struct CursorState {
    cursor_world: Vec2,
    cursor_moved: bool,
}

pub struct Cursor;

pub struct Draggable;
struct Dragged;
pub struct Dropped;

pub struct Hoverable;
struct Hovered;

fn cursor_state(
    mut e_cursor_moved: EventReader<CursorMoved>,
    windows: Res<Windows>,
    mut q_cursor_state: Query<&mut CursorState>,
    q_camera: Query<&Transform, With<Camera>>,
) {
    for mut cursor_state in q_cursor_state.iter_mut() {
        cursor_state.cursor_moved = false;
        for event_cursor_screen in e_cursor_moved.iter() {
            let window = windows.get_primary().unwrap();
            let cam_transform = q_camera.single().unwrap();
            cursor_state.cursor_world =
                cursor_to_world(window, cam_transform, event_cursor_screen.position);

            cursor_state.cursor_moved = true;
        }
    }
}

fn cursor_transform(
    mut commands: Commands,
    q_cursor_state: Query<&CursorState>,
    mut q_cursor: Query<(Entity, &mut Transform), With<Cursor>>,
) {
    if let Ok(cursor_state) = q_cursor_state.single() {
        for (cursor_e, mut transform) in q_cursor.iter_mut() {
            transform.translation.x = cursor_state.cursor_world.x;
            transform.translation.y = cursor_state.cursor_world.y;
            commands.entity(cursor_e).remove::<Parent>();
        }
    }
}

fn hoverable(
    mut commands: Commands,
    q_cursor_state: Query<&CursorState>,
    q_hoverable: Query<(Entity, &Transform, &Sprite), (With<Hoverable>, Without<Dragged>)>,
) {
    if let Ok(cursor_state) =  q_cursor_state.single() {
        if cursor_state.cursor_moved {
            for (entity, transform, sprite) in q_hoverable.iter() {
                let half_width = sprite.size.x / 2.0;
                let half_height = sprite.size.y / 2.0;

                if transform.translation.x - half_width < cursor_state.cursor_world.x
                    && transform.translation.x + half_width > cursor_state.cursor_world.x
                    && transform.translation.y - half_height < cursor_state.cursor_world.y
                    && transform.translation.y + half_height > cursor_state.cursor_world.y
                {
                    commands.entity(entity).insert(Hovered);
                } else {
                    commands.entity(entity).remove::<Hovered>();
                }
            }
        }
    }
}

fn material(
    mut materials: ResMut<Assets<ColorMaterial>>,
    q_hoverable: Query<
        (&Handle<ColorMaterial>, Option<&Hovered>, Option<&Dragged>),
        With<Hoverable>,
    >,
) {
    let mut first = true;

    for (material, hovered, dragged) in q_hoverable.iter() {
        let (red, green, alpha) = if dragged.is_some() {
            (0.0, 1.0, 1.0)
        } else if first && hovered.is_some() {
            first = false;
            (1.0, 0.0, 1.0)
        } else if hovered.is_some() {
            (1.0, 1.0, 0.5)
        } else {
            (1.0, 1.0, 1.0)
        };

        materials.get_mut(material).unwrap().color.set_r(red);
        materials.get_mut(material).unwrap().color.set_g(green);
        materials.get_mut(material).unwrap().color.set_a(alpha);
    }
}

fn cursor_to_world(window: &Window, cam_transform: &Transform, cursor_pos: Vec2) -> Vec2 {
    // get the size of the window
    let size = Vec2::new(window.width() as f32, window.height() as f32);

    // the default orthographic projection is in pixels from the center;
    // just undo the translation
    let screen_pos = cursor_pos - size / 2.0;

    // apply the camera transform
    let out = cam_transform.compute_matrix() * screen_pos.extend(0.0).extend(1.0);
    Vec2::new(out.x, out.y)
}

fn draggable(
    mut commands: Commands,
    i_mouse_button: Res<Input<MouseButton>>,
    q_pressed: Query<Entity, (With<Hovered>, With<Draggable>)>,
    q_released: Query<Entity, With<Dragged>>,
) {
    if i_mouse_button.just_pressed(MouseButton::Left) {
        if let Some(entity) = q_pressed.iter().next() {
            commands.entity(entity).insert(Dragged);
        }
    } else if i_mouse_button.just_released(MouseButton::Left) {
        for entity in q_released.iter() {
            commands.entity(entity).remove::<Dragged>();

            commands.entity(entity).insert(Dropped);
        }
    }
}

fn drag(
    mut commands: Commands,
    mut q_dragged: Query<(Entity, &mut Transform, &GlobalTransform), With<Dragged>>,
    q_cursor: Query<(Entity, &GlobalTransform), With<Cursor>>,
) {
    if let Some((cursor_e, cursor_transform)) = q_cursor.iter().next() {
        for (entity, mut transform, global_transform) in q_dragged.iter_mut() {
            let global_pos = global_transform.translation - cursor_transform.translation;

            commands.entity(entity).insert(Parent(cursor_e));

            transform.translation.x = global_pos.x;
            transform.translation.y = global_pos.y;
        }
    }
}

fn drop(
    mut commands: Commands,
    mut q_dropped: Query<(Entity, &mut Transform, &GlobalTransform), With<Dropped>>,
) {
    for (entity, mut transform, global_transform) in q_dropped.iter_mut() {
        let global_pos = global_transform.translation;

        transform.translation.x = global_pos.x;
        transform.translation.y = global_pos.y;

        commands.entity(entity).remove::<Parent>();
        commands.entity(entity).remove::<Dropped>();
    }
}
